PROGRAMA {
    @ T2 (uint), T5 (float), T9 (var)
    var GUINT := 10UI;
    var GFLOAT := 1.5F+1;

    @ T21(Ret. Mult), T25(CR), T28(Lambda Param)
    float, uint FUNCCR(cr se uint PSE, cr le float PLE, lambda PLAM) {

        @ T25: Error Semantico -> PSE (solo escritura) no puede ser leido.
        GUINT := PSE + 1UI;

        @ T25: OK -> PLE (lectura/escritura) puede ser leido y escrito.
        PLE := PLE + 1.0F+0;

        @ T25: OK -> PSE (solo escritura) puede ser escrito.
        PSE := 100UI;

        @ T28: OK -> Invocacion de parametro lambda
        PLAM(1UI -> X);

        @ T21: OK -> Retorno multiple (float, uint)
        return (PLE, 5UI);
    }

    @ T9: Inferencia en ambito local
    var A := 1UI;
    var B := 2UI;
    var F := 10.0F+0;

    @ T19: OK -> Asignacion Multiple Restringida
    A, B = 3UI, 4UI;

    @ T31: OK -> Conversion Explicita (float -> uint)
    A := toui(F);

    @ T14: OK -> DO-WHILE
    do {
        @ T8: OK -> Print con cadena multilinea
        print(&Iterando...
    A es: &);
        print(A);
        A := A - 1UI;
    } while (A > 0UI);

    @ T21, T25, T28: OK -> Invocacion a funcion CR con Lambda y asignacion multiple
    @ T21: Warning -> la funcion retorna 2 valores, se asigna 1. Se descarta el segundo.
    F = FUNCCR(A -> PSE, F -> PLE, (uint K){ print(&Lambda Invocada!&); } -> PLAM);

    @ T23: OK -> Prefijado Opcional (Asumiendo que PRUEBATP3 es el ambito)
    A := PRUEBATP3.GUINT;

    @ =================================================================
    @ SECCION DE ERRORES
    @ =================================================================

    @ T31: Error Semantico -> operacion uint y float sin conversion
    A := GUINT + GFLOAT;

    @ T19: Error Semantico -> distinto numero de elementos
    A, B = 1UI;

    @ T9: Error Semantico -> redeclaracion de A en el mismo ambito
    var A := 5UI;

    @ T14: Error Sintactico -> falta ';' al final de DO-WHILE
    do {
        A := 1UI;
    } while (A > 0UI)

    @ T21: Error Semantico -> menos retornos (2) que asignaciones (3)
    A, B, F = FUNCCR(A -> PSE, F -> PLE, (uint K){ print(&Lambda Error!&); } -> PLAM);

    if (A == B) {
        print(&son iguales&);
    } endif;

    if (A == B) {
        print(&son iguales&);
    } else {
        print(&son distintos&);
    } endif;

    uint APLICARLAMBDA(lambda FUNC, uint VALOR) {
        print(&Ejecuta LAMBDA&);
        return( FUNC(VALOR->X) );
    }
    var RESULTADO := 0UI;
    RESULTADO := APLICARLAMBDA( (uint A){ return(A + 10UI); } , 5UI );

    print(&El resultado final es:&);
    print(RESULTADO);
    F.A := J;
    F := J.A;
    A,B = F.A, J;
    F.A, B = A,J;

    W := A + B;
    var X := 100UI;
    uint X := 100UI;

    do {
        A := A - 1UI;
        print(&Iterando en el bucle...&);
    } while (A > 0UI);

    A, B, X = 100UI, VARUINT, .5F+1;
    A, B, X = 100UI, VARUINT;
    A, B = 100UI, VARUINT, .5F+1;

    float, uint, float F(uint X) {
        return (1UI, 4UI, 2UI);
    }
    A, B, C, D = F(1UI->X);
    A, B = F(1UI->X);

    uint F (cr se uint X, cr le uint Y, uint Z) {
        return (X, Y, Z);
    }

    A := toui(X;
    A := toui(X);
}