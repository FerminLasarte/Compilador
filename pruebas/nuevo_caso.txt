MAIN {
    @ Temas: 2, 5, 8, 9, 14, 19, 21, 23, 25, 28, 31, 32

    var GCONTADOR := 0UI;
    var GCONTADOR1 := 1UI;
    var GFACTOR := 1.0F+0;
    var X := GCONTADOR + GCONTADOR1;
    X := GCONTADOR + GFACTOR;

    var VARA := 1UI;
    var VARF := 1.0F+0;
    VARA := toui(VARF);

    var A := 1UI;
    var B := 2UI;
    var C := 5.0F+0;
    A,B,C = 10UI, 20UI, 1.0F+0;

    var Z := 1UI;

    uint FUNCZ(uint Z) {

        var W := 2UI;
        var Y := 3UI;
        W := MAIN.A;
        Y := W;

        return(W);
    }

    float, uint FUNCCOMPLETA(cr se uint PSE, cr le uint PLE) {

        PLE := PLE + 1UI;
        PSE := 100UI;
        PLE := PSE;
        return (PLE, PSE);
    }

    do {
        print(& PRINT GCONTADOR &);
        print(MAIN.GCONTADOR);
        MAIN.GCONTADOR := MAIN.GCONTADOR + 1UI;
    } while (MAIN.GCONTADOR < 3UI);

}



    if (MAIN.A < 5UI) {
        print(& PRINT A &);
        print(MAIN.A);
    } else print(100UI);



@ Función auxiliar para T19
uint FUNCSIMPLE(uint DUMMY) {
    return (100UI);
}

@ =============================================
@ BLOQUE PRINCIPAL (MAIN)
@ =============================================

@ T14 (do-while) y T8 (print cadena multilinea)


@ T9: Declaraciones locales
var VARA := 1UI;
var VARB := 2UI;

@ T19 (Asignación Múltiple Restringida)
@ Lado derecho solo vars, ctes, o invocaciones (no expresiones)
VARA, VARB = 3UI, 4UI; @ OK: Cte, Cte
VARA, VARB = GCONTADOR, VARA; @ OK: Var, Var
VARA, VARB = 1UI, FUNCSIMPLE(1UI -> DUMMY); @ OK: Cte, Invocacion

@ T21 (Ret. Multiple), T28 (Lambda Call)
@ FUNCCOMPLETA retorna (float, uint)
var VARF := 0.0F+0;
@ T21 Warning: Se asignan 1 de 2 retornos. Se descarta el 'uint' (PSE).
VARF = FUNCCOMPLETA(
    1UI -> PSE,
    2.0F+0 -> PLE,
    (uint K){ print(&Lambda llamada OK!&); } -> PLAM @ T28: OK
);

@ T23 (Prefijado Opcional)
@ 'GCONTADOR' local (float) "oculta" al global (uint)
var GCONTADOR := 100.0F+0;
VARF := GCONTADOR; @ OK: Accede a GCONTADOR local (float)
@ T23: OK - Accede a GCONTADOR global (uint) usando prefijo
VARA := PROGRAMAT9OBLIGATORIO.GCONTADOR;

@ T31 (toui): Conversion explicita float -> uint
VARA := toui(VARF); @ OK: toui(float)


@ =============================================
@ SECCION DE ERRORES
@ =============================================

@ T32: Esto es un comentario valido @

@ T2 Error Lexico: uint fuera de rango (65536 > 65535)
var EUINTRANGO := 65536UI;

@ T5 Error Lexico: float fuera de rango
var EFLOATRANGO := 3.40282348F+38;

@ T5 Error Lexico: float mal formado (falta signo exponente)
var EFLOATFORMATO := 1.F10;

@ T9 Error Sintactico: Declaracion dentro de DO-WHILE (Prohibido)
do {
    var EVARBLOQUE := 1UI;
} while (VARA > 0UI);

@ T14 Error Sintactico: Falta ';' al final del do-while
do {
    VARA := 0UI;
} while (VARA > 0UI)

@ T9 Error Semantico: Redeclaracion de VARA en el mismo ambito
var VARA := 1UI;

@ T19 Error Sintactico/Semantico: Expresion 'VARA + 1UI' no permitida (Tema 19)
VARA, VARB = 1UI, VARA + 1UI;

@ T19 Error Semantico: Disparidad de elementos (2 izq, 1 der)
VARA, VARB = 1UI;

@ T21 Error Semantico: Mas variables (3) que retornos (2)
var VARC := 1UI;
VARF, VARA, VARC = FUNCCOMPLETA(1UI -> PSE, 2.0F+0 -> PLE, (uint K){ print(&L&); } -> PLAM);

@ T23 Error Semantico: Ambito/Variable no existe
VARA := AMBITOFALSO.NOEXISTE;

@ T25: Error Semantico (Leer 'cr se')
float, uint FUNCERRORCR(cr se uint PSEERR) {
    @ T25 Error: PSEERR es solo escritura (se), no puede leerse
    var TEMP := PSEERR;
    return (0.0F+0, TEMP);
}

@ T28 Error Semantico: Pasar 'uint' (10UI) a parametro 'lambda'
VARF = FUNCCOMPLETA(1UI -> PSE, 2.0F+0 -> PLE, 10UI -> PLAM);

@ T31 Error Semantico: Asignar float a uint sin 'toui'
VARA := VARF;

@ T31 Error Semantico: Operar uint y float sin 'toui'
VARA := VARA + VARF;

@ T31 Error Semantico: 'toui' aplicado a 'uint' (solo aplica a float)
VARA := toui(VARA);

}